##
Changes:

1. Symbolizer and Desymbolizer isn't very OO'ey.  I instead moved to Pitches and PitchSymbols that know
   how to convert to one another.
2. PitchIntervalTranscoder is also not very OO'ey.  I moved to an Interval.calculate that knows how to
   calculate an interval from two pitches.  It'll be someone's responsibility to retain state (the last
   pitch) and to branch on whether or not there IS a last pitch.

##

InteractiveImprovisor
	Build
		sensor = Sensor.new
		sensor.register_midi_in_port(InPort)

		listener = Listener.new
		
		improvisor = Improvisor.new
		for each improvisor.GetCritics |cricic|
			listener.AddCritic critic

		performer = Performer.new 
		performer.register_midi_out_port(OutPort)
	Execute # run in thread, be prepared to stop?
		stimulus_events = Sensor.GetStimulus # returns an EventQueue
		stimulus_notes = stimulus_events.ToNoteQueue

		Listener.Listen(stimulus_notes)

		response_notes = Improvisor.Generate
		response_events = response_notes.ToEventQueue

		Performer.perform(response_events)
	Has: Sensor
	Has: Listener
	Has: Improvisor
	Has: Performer

Sensor
	RegisterMidiInPort(InPort)
	GetStimulus
		# this will require a refactor of Midi::InPort to introduce a 
		# read that allows a timeout.  Then our end-of-stimulus event is just implemented
		# as a timeout, after having received at least one note-on/-off event
		Calls Midi::InPort::BlockingRead 
		Accumulates into a EventQueue
		Listens for the end of a stimulus
		Returns a complete EventQueue

Listener
	Listen(NoteQueue) # a completed stimulus
		Takes a NoteQueue
		Resets all critics
		For each Note in NoteQueue
			Cause each critics to listen
	AddCritic
		Adds the critic to the internal list of critics who will listen to each note

Improvisor
	Generate
		Resets each of the critics
		Uses NoteGenerator to generate an entire stimulus (sequence of notes)
	GetCritics
		Returns a list of critics
	Has: NoteGenerator
		Reset
		Generate
			Uses PitchGenerator and DurationGenerator to generate another note
		GetCritics
		Has: PitchGenerator
			Reset
			Generate
				Gets expectations from critics
				Makes decision # make the expectations object the decider?
			GetCritics
			Has: PitchCritic
			Has: IntervalCritic
		Has: DurationGenerator
			Reset
			Generate
				Gets expectations from critics
				Makes decision # make the expectations object the decider?
			GetCritics
			Has: DurationCritic

Performer
	RegisterMidiOutPort(OutPort)
	Perform(EventQueue)
		EventQueue.each |event|
			Midi::OutPort::Write
	Has: Midi::OutPort

EventQueue
	ToNoteQueue
	 	Extract Pitches
	  	Extract Durations (IOIs)
			# Use IOIs (NoteOn-to-NoteOn) when next NoteOn exists
			# Use Duration (NoteOn-to-NoteOff) when no more NoteOn's (last note)
	  	Quantize Durations & Find Tempo

PitchCritic
	Reset
		Reset state
	Listen(Note)
		next_symbol = Note.pitch.to_symbol
		surprise = markov_chain.cur_state.get_surprise(next_symbol)
		markov_chain.set_cur_state(next_symbol)
		return surprise
	GetExpectations
		return markov_chain.cur_state.expectations # excpet we need to desymbolize the states

IntervalCritic
	Reset
		Reset state
	Listen(Note)
		note_history.enqueue(cur_note)
		if note_history.length >= 2
			interval = Interval.calculate(note_history[-2].pitch, note_history[-1].pitch)
			note_history.dequeue
			next_symbol = interval.to_symbol

			surprise = markov_chain.cur_state.get_surprise(next_symbol)
			markov_chain.set_cur_state(next_symbol)
			return surprise
		return nil
	GetExpectations
		Returns possible next states & probabilities
	Has: PitchIntervalTranscoder
		PitchToInterval
			Takes Pitch, queues it
			If there are are two pitches
				Calculate interval
				Consume the older pitch
				Returns interval
		IntervalToPitch
			Takes Interval, adds to last pitch
			Returns Pitch

DurationCritic
	Reset
		Reset state
	Listen(Note)
		next_symbol = Note.duration.to_symbol
		surprise = markov_chain.cur_state.get_surprise(next_symbol)
		markov_chain.set_cur_state(next_symbol)
		return surprise
	GetExpectations
		Returns possible next states & probabilities

MarkovChain
	Has: MarkovState
		# Refactoring part of this out into an Expectations class?
		Has: Expectations

MarkovChain could implement a generic API for taking in sequential states and returning expectations about the future:

SequencePredictor
	Reset
	AcceptSymbol
		return surprise
	GetExpectations
		return a decider
